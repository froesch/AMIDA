package functionalunit.tokenmachine;

import dataContainer.ByteCode;
import tracer.TraceManager;
import functionalunit.TokenMachine;
import functionalunit.opcodes.*;

/**
 * Extension of the abstract class TokenMachine DO NOT MODIFY - GENERATED BY
 * ADLA COMPILER Implements the method decodeByteCode(byte code)
 * 
 * @author jung
 *
 */
public class TokenMachineAdla extends TokenMachine {

	private static final int PORT_A = 0, PORT_B = 1, PORT_C = 2;

	private static final boolean TAG_INC = true, NO_TAG_INC = false;

	public TokenMachineAdla(String configFile, TraceManager traceManager) {
		super(configFile, traceManager);
	}

	int count = 0;
	int currentTag = 0;

	private int loopBackJumpAddr = 0;

	public boolean tokenDecodingDone() {
		return count == 0;
	}

	int wide = 0;

	public void decodeByteCode(byte code) {
		// System.out.println("DEconding " + ByteCode.debug(code));
		int extendedcode = code;
		if (wide != 0) {
			extendedcode = (code & 0xFF) + wide;
		}
		wide = 0;
		switch(extendedcode){
		case ByteCode.NOP:
			switch(count){
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ACONST_NULL:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ACONST, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_M1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_M1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_4:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_4, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ICONST_5:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.ICONST_5, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LCONST_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LCONST_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LCONST_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LCONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FCONST_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.FCONST_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FCONST_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.FCONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FCONST_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.FCONST_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DCONST_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DCONST_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DCONST_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DCONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.BIPUSH:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.SIPUSH:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.ILOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.LLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.FLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.DLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.ALOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.ILOAD_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ILOAD_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ILOAD_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ILOAD_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LLOAD_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LLOAD_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LLOAD_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LLOAD_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FLOAD_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FLOAD_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FLOAD_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FLOAD_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DLOAD_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DLOAD_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DLOAD_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DLOAD_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD64_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ALOAD_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ALOAD_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ALOAD_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ALOAD_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.LOAD32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY_64, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY_64, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.AALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.BALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.CALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.SALOAD:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_READ_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.LSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.FSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.DSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.ASTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.ISTORE_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISTORE_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISTORE_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISTORE_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSTORE_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSTORE_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSTORE_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSTORE_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FSTORE_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FSTORE_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FSTORE_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FSTORE_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DSTORE_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DSTORE_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DSTORE_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DSTORE_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE64_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ASTORE_0:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_0, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ASTORE_1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ASTORE_2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ASTORE_3:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.STORE32_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY_64, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY_64, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.AASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.BASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.CASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.SASTORE:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.HO_WRITE_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.POP:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.REMOVE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.POP2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.REMOVE64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP_X1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP_X1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP_X2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP_X2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP2_X1:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP2_X1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DUP2_X2:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP2_X2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.SWAP:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.SWAP, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IADD:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IADD, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LADD:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LADD, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FADD:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_ADD, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DADD:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_ADD, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISUB:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ISUB, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSUB:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LSUB, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FSUB:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_SUB, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DSUB:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_SUB, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IMUL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IMUL, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LMUL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LMUL, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FMUL:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_MUL, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DMUL:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_MUL, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IDIV:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IDIV, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LDIV:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LDIV, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FDIV:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_DIV, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DDIV:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_DIV, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IREM:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IREM, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LREM:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LREM, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FREM:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP2, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_DIV, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 3:
				//	frameStack.addToken(FrameStackOpcodes.SWAP, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 4:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_TRUNC, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 5:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 6:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_MUL, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 7:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 8:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 9:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_SUB, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 10:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 11:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 12:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DREM:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP2_X2, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_DIV, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.DUP2_X2, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 3:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 4:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_TRUNC, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 5:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 6:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_MUL, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 7:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 8:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 9:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_SUB, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 10:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 11:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 12:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.INEG:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.INEG, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LNEG:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LNEG, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FNEG:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_NEG, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DNEG:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_NEG, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISHL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ISHL, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSHL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LSHL, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ISHR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ISHR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LSHR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LSHR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IUSHR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IUSHR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LUSHR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LUSHR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IAND:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IAND, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LAND:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LAND, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IOR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IOR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LOR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LOR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IXOR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.IXOR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LXOR:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LXOR, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IINC:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					ialu.addToken(IaluOpcodes.IADD, currentTag, frameStack, PORT_A, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_2, currentTag, ialu, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 3:
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 3;
			break;
		case ByteCode.I2L:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.I2L, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.I2F:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.INT_2_FLOAT, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.I2D:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.INT_2_DOUBLE, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.L2I:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.L2I, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.L2F:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.LONG_2_FLOAT, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.L2D:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.LONG_2_DOUBLE, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.F2I:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_2_INT, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.F2L:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_2_LONG, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.F2D:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_2_DOUBLE, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.D2I:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_2_INT, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.D2L:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_2_LONG, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.D2F:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_2_FLOAT, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.I2B:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.I2B, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.I2C:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.I2C, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.I2S:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.I2S, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LCMP:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.LCMP, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FCMPL:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_LST, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FCMPG:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.FLOAT_GRT, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DCMPL:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_LST, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DCMPG:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_B, NO_TAG_INC);
					falu.addToken(FaluOpcodes.DOUBLE_GRT, currentTag, frameStack, PORT_A, TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, falu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IFEQ:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_EQ, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFNE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_NE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFLT:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_LT, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFGE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_GE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFGT:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_GT, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFLE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_LE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPEQ:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_EQ, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPNE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_NE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPLT:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_LT, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPGE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_GE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPGT:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_GT, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ICMPLE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_LE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ACMPEQ:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_EQ, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IF_ACMPNE:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_NE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GOTO:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.JSR:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.JSR, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.RET:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.RET, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.IRETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN32, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.LRETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN64, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.FRETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN32, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.DRETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN64, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ARETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN32, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.RETURN:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.RETURN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.RETURN, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ARRAYLENGTH:
			switch(count){
				case 0:
					heap.addToken(HeapOpcodes.GET_SIZE, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.ATHROW:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.DUP, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					heap.addToken(HeapOpcodes.GET_CTI, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, tokenMachine, PORT_B, TAG_INC);
					currentTag++;
					count++;
					break;
				case 3:
					tokenMachine.addToken(TokenMachineOpcodes.THROW, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.CLEARFRAME, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 4:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.IFNULL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_EQ, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.IFNONNULL:
			switch(count){
				case 0:
					ialu.addToken(IaluOpcodes.ICMP_ZERO, currentTag, tokenMachine, PORT_B, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH_IF_NE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GOTO_W:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2_3_4, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 4;
			sendConstantCount = 1;
			break;
		case ByteCode.JSR_W:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2_3_4, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.JSR, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 4;
			sendConstantCount = 1;
			break;
		case ByteCode.LDC_W_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.LDC, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.LDC2_W_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.LDC2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETFIELD_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.PUTFIELD_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_WRITE, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETFIELD2_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ_64, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.PUTFIELD2_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_WRITE_64, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETSTATIC_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.PUTSTATIC_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_WRITE, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETSTATIC2_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ_64, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSH64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.PUTSTATIC2_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_WRITE_64, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP64, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.INVOKEVIRTUAL_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_ARG_RMTI, currentTag, frameStack, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.GET_CTI, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PEEK, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.INVOKE, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.INVOKE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.INVOKENONVIRTUAL_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.INVOKE_STATIC, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.INVOKE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.INVOKESTATIC_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.INVOKE_STATIC, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.INVOKE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.INVOKEINTERFACE_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2_3_4, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_ARG_IOLI_RIMTI, currentTag, frameStack, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.GET_CTI, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PEEK, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.INVOKE_INTERFACE, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.INVOKE, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 4;
			sendConstantCount = 1;
			break;
		case ByteCode.NEWARRAY_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.NEWARRAY_CTI, currentTag, heap, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.ALLOC_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 1;
			sendConstantCount = 1;
			break;
		case ByteCode.NEW_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.CLASSSIZE, currentTag, heap, PORT_B, TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.ALLOC_OBJ, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 2;
			break;
		case ByteCode.ANEWARRAY_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.ALLOC_ARRAY, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.MULTIANEWARRAY_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_A, NO_TAG_INC);
					heap.addToken(HeapOpcodes.SETUP_MULTI_ARRAY, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_3, currentTag, heap, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.LOOP_0_BYTECODE_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 3:
					// Loop Start
					if(!loopIterationsValid){
						break;
					}
					if(loopIterations == 0){
						count++;
						break;
					}
					heap.addToken(HeapOpcodes.SET_MULTI_ARRAY_DIM_SIZE, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 4:
					// Loop End
					if(loopIterations-- > 1){
						count = 3;
						break;
					}
					loopIterationsValid = false;
					heap.addToken(HeapOpcodes.ALLOC_MULTI_ARRAY, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 3;
			sendConstantCount = 2;
			break;
		case ByteCode.CHECKCAST_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_B, TAG_INC);
					heap.addToken(HeapOpcodes.GET_CTI, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PEEK_1, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.CHECKCAST, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.INSTANCEOF_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_B, TAG_INC);
					heap.addToken(HeapOpcodes.GET_CTI, currentTag, tokenMachine, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.INSTANCEOF, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.LDC_STRING:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETFIELDA_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.GETSTATICA_QUICK:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, heap, PORT_B, NO_TAG_INC);
					heap.addToken(HeapOpcodes.HO_READ, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.ICONST_1, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.REF_TO_INT:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.INT_TO_REF:
			switch(count){
				case 0:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, frameStack, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.PUSHREF, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		case ByteCode.READ_ADDRESS:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					heap.addToken(HeapOpcodes.PHY_READ, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.NOP_CONST, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WRITE_ADDRESS:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, tokenMachine, PORT_A, TAG_INC);
					heap.addToken(HeapOpcodes.PHY_WRITE, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_C, NO_TAG_INC);
					count++;
					break;
				case 1:
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, heap, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.NOP_CONST, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
//		case ByteCode.DISABLE_SCHEDULING:
//			switch(count){
//				case 0:
//					scheduler.addToken(SchedulerOpcodes.DISABLESCHEDULING, currentTag, null, PORT_A, NO_TAG_INC);
//					currentTag++;
//
//					count = 0;
//					break;
//			}
//			isJump = false;
//			bytecodeOffset = 0;
//			sendConstantCount = 0;
//			break;
//		case ByteCode.FORCE_SCHEDULING:
//			switch(count){
//				case 0:
//					tokenMachine.addToken(TokenMachineOpcodes.FORCESCHEDULING, currentTag, null, PORT_A, NO_TAG_INC);
//					scheduler.addToken(SchedulerOpcodes.FORCESCHEDULING, currentTag, null, PORT_A, NO_TAG_INC);
//					currentTag++;
//
//					count = 0;
//					break;
//			}
//			isJump = true;
//			bytecodeOffset = 0;
//			sendConstantCount = 0;
//			break;
//		case ByteCode.ENABLE_SCHEDULING:
//			switch(count){
//				case 0:
//					scheduler.addToken(SchedulerOpcodes.ENABLESCHEDULING, currentTag, null, PORT_A, NO_TAG_INC);
//					currentTag++;
//
//					count = 0;
//					break;
//			}
//			isJump = false;
//			bytecodeOffset = 0;
//			sendConstantCount = 0;
//			break;
		case ByteCode.SYNTH_INIT:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.SYNTH_INIT, currentTag, frameStack, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.LOOP_0_BYTECODE_2, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 3:
					// Loop Start
					if(!loopIterationsValid){
						break;
					}
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, frameStack, PORT_A, NO_TAG_INC);
					cgra.addToken(CgraOpcodes.RECEIVELOCALVAR, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 4:
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, cgra, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, cgra, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 5:
					// Loop End
					if(loopIterations-- > 1){
						count = 3;
						break;
					}
					loopIterationsValid = false;
					tokenMachine.addToken(TokenMachineOpcodes.LOOP_0_BYTECODE_3, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 6:
					// Loop Start
					if(!loopIterationsValid){
						break;
					}
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					cgra.addToken(CgraOpcodes.RECEIVELOCALVAR, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 7:
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LDC, currentTag, cgra, PORT_B, NO_TAG_INC);
					count++;
					break;
				case 8:
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, cgra, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 9:
					// Loop End
					if(loopIterations-- > 1){
						count = 6;
						break;
					}
					loopIterationsValid = false;
					tokenMachine.addToken(TokenMachineOpcodes.LOOP_0_BYTECODE_4, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 10:
					// Loop Start
					if(!loopIterationsValid){
						break;
					}
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, cgra, PORT_B, NO_TAG_INC);
					cgra.addToken(CgraOpcodes.RECEIVELOCALVAR, currentTag, null, PORT_A, NO_TAG_INC);
					count++;
					break;
				case 11:
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, cgra, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 12:
					// Loop End
					if(loopIterations-- > 1){
						count = 10;
						break;
					}
					loopIterationsValid = false;
					cgra.addToken(CgraOpcodes.RUN, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, cgra, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 4;
			sendConstantCount = 1;
			break;
		case ByteCode.SYNTH_START:
			switch(count){
				case 0:
					currentTag++;
					count++;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.LOOP_0_BYTECODE_1, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 2:
					// Loop Start
					if(!loopIterationsValid){
						break;
					}
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, cgra, PORT_A, NO_TAG_INC);
					cgra.addToken(CgraOpcodes.SENDLOCALVAR, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 3:
					if(loopIterations == 0){
						count++;
						break;
					}
					tokenMachine.addToken(TokenMachineOpcodes.LOAD_SYNTH_CONST, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					break;
				case 4:
					// Loop End
					if(loopIterations-- > 1){
						count = 2;
						break;
					}
					loopIterationsValid = false;
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_3_4, currentTag, tokenMachine, PORT_A, TAG_INC);
					currentTag++;
					count++;
					break;
				case 5:
					tokenMachine.addToken(TokenMachineOpcodes.BRANCH, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 4;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_ILOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_LLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_FLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_DLOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_ALOAD:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_ISTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_LSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_FSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_DSTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE64, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_ASTORE:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE_IINC:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					wide = 0x100;
					break;
				case 1:
					ialu.addToken(IaluOpcodes.IADD, currentTag, frameStack, PORT_A, TAG_INC);
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_3_4, currentTag, ialu, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, ialu, PORT_B, NO_TAG_INC);
					currentTag++;
					count++;
					wide = 0x100;
					break;
				case 2:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, TAG_INC);
					frameStack.addToken(FrameStackOpcodes.PUSH32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					wide = 0x100;
					break;
				case 3:
					frameStack.addToken(FrameStackOpcodes.STORE32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = false;
			bytecodeOffset = 4;
			sendConstantCount = 3;
			break;
		case ByteCode.WIDE_RET:
			switch(count){
				case 0:
					tokenMachine.addToken(TokenMachineOpcodes.SENDBYTECODE_1_2, currentTag, frameStack, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.LOAD32, currentTag, null, PORT_A, NO_TAG_INC);
					currentTag++;
					count++;
					wide = 0x100;
					break;
				case 1:
					tokenMachine.addToken(TokenMachineOpcodes.RET, currentTag, null, PORT_A, NO_TAG_INC);
					frameStack.addToken(FrameStackOpcodes.POP32, currentTag, tokenMachine, PORT_A, NO_TAG_INC);
					currentTag++;

					count = 0;
					break;
			}
			isJump = true;
			bytecodeOffset = 2;
			sendConstantCount = 1;
			break;
		case ByteCode.WIDE:
			wide = 0x100;		isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
		default:
			isJump = false;
			bytecodeOffset = 0;
			sendConstantCount = 0;
			break;
	}

	}
}
